# 01｜项目结构与开发方式（以生命周期驱动主程序 + 组件化）

本项目的目标是：把“应用启动/运行/暂停/停止/销毁”等流程当作一条 **生命周期主线** 来组织代码。

- **主程序（Main）只做调度，不承载业务细节**。
- 每个生命周期阶段（或生命周期事件）要做的事情，放进单独的 **组件（Component）** 里。

这样做的好处：

1. **结构清晰**：你一眼就能从主程序看到“应用会经历哪些生命周期”。
2. **低耦合**：组件之间不直接互相调用，减少“牵一发而动全身”。
3. **便于扩展**：增加新功能时，往往就是增加一个新组件，并订阅对应的生命周期事件。
4. **便于测试**：组件是独立类，可以单测其对事件的反应。

---

## 1. 核心概念

本项目包含三类核心角色：

### 1.1 Lifecycle（生命周期）

- 维护当前 `state`（状态）
- 接收 `event`（事件）并推进状态机
- 通知所有观察者（observers）

代码位置：`src/main/kotlin/cn/ctonew/lifecycle/core/Lifecycle.kt`

### 1.2 LifecycleOwner（生命周期所有者）

- 持有一个 `lifecycle`
- 代表“某个具有生命周期的对象”（例如：应用、页面、窗口、一个功能子树……）

代码位置：`src/main/kotlin/cn/ctonew/lifecycle/core/LifecycleOwner.kt`

### 1.3 LifecycleComponent（生命周期组件）

- 组件不主动驱动生命周期；它只做一件事：
  - **订阅生命周期事件**
  - 在对应事件发生时执行自己的逻辑

代码位置：`src/main/kotlin/cn/ctonew/lifecycle/components/*`

---

## 2. 你应该如何写主程序

主程序（`Main.kt`）建议遵循固定模板：

1. 创建 `LifecycleOwner`
2. 创建并安装组件列表（install）
3. 依次触发生命周期事件（handleEvent）
4. 结束时可选择卸载组件（uninstall）

主程序只做这些事，**不要把业务逻辑写进 Main**。

---

## 3. 如何新增一个“生命周期阶段组件”

假设你要在 `ON_START` 阶段启动某个服务：

1. 在 `components/` 下创建新类，例如：`OnStartServiceComponent.kt`
2. 让它实现 `LifecycleComponent`
3. 在组件内部订阅 `ON_START` 事件
4. 在 `Main.kt` 中把组件加入安装列表

这样你就能做到：

- 功能逻辑在组件里
- 生命周期调度在主程序里
- 二者分离，结构稳定

---

## 4. 与 Compose Multiplatform 的对应关系（简述）

本项目的 `Lifecycle / LifecycleOwner / Observer` 是“教学版”。

在 Compose Multiplatform 中，你会用到官方实现：

- `androidx.lifecycle.Lifecycle`
- `androidx.lifecycle.LifecycleOwner`
- `androidx.lifecycle.LifecycleEventObserver`
- `LocalLifecycleOwner`（通过 CompositionLocal 提供）

更详细的说明与平台映射见：`docs/02_Lifecycle_生命周期.md`
